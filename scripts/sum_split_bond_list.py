import re, sys, os, argparse

def read_bond_list_piece(max_step_num, fp):
    xss = []
    regexp_float = r'[+-]?(\d+\.)?\d+([deE][+-]?\d+)?'
    step_num = -1
    for line in fp:
        m = re.match(r'## step_count =\s+(\d+)', line)
        if m:
            step_num += 1
            if step_num >= max_step_num:
                break
            xss.append([])
        else:
            m = re.search(r'(?P<a2>\d+)\s+(?P<o1>\d+)\s+(?P<a1>\d+)\s+(?P<icohp>%s)' % regexp_float, line)
            if m:
                atom2 = int(m.group('a2')) - 1  # 1-origin to 0-origin.
                orbital1 = int(m.group('o1')) - 1
                atom1 = int(m.group('a1')) - 1
                icohp = float(m.group('icohp'))
                xss[step_num].append((atom2, orbital1, atom1, icohp))
    return xss

def mmwrite_symmetric(mtx, m, n, filename, comment):
    with open(filename, 'w') as fp:
        fp.write('%%MatrixMarket matrix coordinate real symmetric\n')
        fp.write('%%%s\n' % comment)
        num_nonzeros = 0
        for i, j in mtx.keys():
            num_nonzeros += 1
        fp.write('%7d %7d %12d\n' % (m, n, num_nonzeros))
        for (i, j), x in mtx.items():
            fp.write('%7d %7d % .16e\n' % (i + 1, j + 1, x))  # The space between % and . is intended.

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('num_atoms', metavar='NUM_ATOMS', type=int,
                        help='The number of atoms in the whole system')
    parser.add_argument('molecule_size', metavar='MOLECULE_SIZE', type=int,
                        help='The number of atoms in a molecule')
    parser.add_argument('-m', metavar='MAX_NUM_FILES', dest='max_num_files', type=int, default=None,
                        help='Limit the max number of input files')
    parser.add_argument('-s', metavar='MAX_STEP_NUM', dest='max_step_num', type=int, default=1,
                        help='Max step number to output (default: 1)')
    parser.add_argument('-d', metavar='INPUT_DIR', dest='input_dir', type=str, default='.',
                        help='Input directory contains output_bond_list files by ELSES')
    parser.add_argument('-o', metavar='OUTPUT_HEADER', dest='output_header', type=str,
                        default='bond_list_molecule_symmetrized',
                        help='Header for output filename')
    args = parser.parse_args()

    # The number of atoms and molecules are computed and empty matrix variables are allocated.
    assert(args.num_atoms % args.molecule_size == 0)
    num_molecules = args.num_atoms / args.molecule_size
    Xs = []
    for i in range(args.max_step_num):
        Xs.append({})

    # Get the list of input files.
    assert(os.path.isdir(args.input_dir))
    split_bond_list_filenames = filter(lambda s: s.find('output_bond_list') >= 0, os.listdir(args.input_dir))

    for n, f in enumerate(split_bond_list_filenames):
        if args.max_num_files is not None and n >= args.max_num_files:
            print 'max_num_files %d reached, break' % args.max_num_files
            break
        print 'start reading %d / %d: %s' % (n + 1, len(split_bond_list_filenames), f)
        with open(os.path.join(args.input_dir, f)) as fp:
            xss = read_bond_list_piece(args.max_step_num, fp)
            for step_num in range(len(xss)):
                for (atom2, orbital1, atom1, icohp) in xss[step_num]:
                    key = (atom1 / args.molecule_size, atom2 / args.molecule_size)
                    key_transpose = (key[1], key[0])  # Symmetrize here.
                    if not key in Xs[step_num]:
                        Xs[step_num][key] = 0.0
                    if not key_transpose in Xs[step_num]:
                        Xs[step_num][key_transpose] = 0.0
                    Xs[step_num][key] += icohp / 2.0
                    Xs[step_num][key_transpose] += icohp / 2.0

    # Output in the format of MatrixMarket file.
    for step_num, X in enumerate(Xs):
        if args.max_step_num > 1:
            output_filename = '%s_%06d.mtx' % (args.output_header, step_num)
        else:
            output_filename = '%s.mtx' % args.output_header
        mmwrite_symmetric(X, num_molecules, num_molecules, output_filename,
                          'generated by sum_split_bond_list.py. command: ' + ' '.join(sys.argv))
